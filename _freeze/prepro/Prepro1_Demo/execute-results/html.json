{
  "hash": "cf98e5b811a2c3a98fa061493af9d0cf",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 2024-02-20\nlesson: PrePro1\ntopic: Data Types\nindex: 1\n---\n\n# Prepro 1: Demo\n\nThis demo's source code can also [be downloaded as an R Script](Prepro1_Demo.R) (right click → *Save Target As..*)\n\n## Data types\n\n### Doubles\n\nThere are two different `numeric` data types in R:\n\n- `double`: floating-point number (e.g. 10.3, 7.3)\n- `integer` (e.g. 10, 7)\n\n\nA double / floating point number is assigned to a variable as follows:\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10.3\n\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.3\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n:::{.callout-note}\n\nEither `<-` or `=` can be used. However, the latter is also easily confused with `==`.\n\n::: {.cell}\n\n```{.r .cell-code}\ny = 7.3\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.3\n```\n\n\n:::\n:::\n\n\n:::\n\n### Integer\n\nA number is only stored as an `integer` if it is explicitly defined as one (using `as.integer()` or `L`).\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- 8L\n\nclass(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n### Boolean\n\n::: {.cell}\n\n```{.r .cell-code}\nsunny <- FALSE\ndry <- TRUE\n\nsunny & dry\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- 3\nf <- 6\n\ne > f\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n### Character\n\n**Character** strings contain text.\n\n::: {.cell}\n\n```{.r .cell-code}\nfname <- \"Andrea\"\nlname <- \"Muster\"\nclass(fname)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\nConnecting / concatenating character strings\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(fname, lname)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Andrea Muster\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(fname, lname, sep = \",\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Andrea,Muster\"\n```\n\n\n:::\n:::\n\n\n<!--\n\n### Factors\n\nFactors in R denote a collection of repeating character strings, e.g. the policical parties represented in the federal council (\"Bundesrat\").\n\n::: {.cell}\n\n```{.r .cell-code}\n# with c(), we can combine multiple character strings\n# we will learn about this later\nbundesrat <- c(\"die Mitte\",\"FDP\", \"SVP\", \"FDP\", \"SVP\", \"SP\", \"SP\")\n\nclass(bundesrat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbundesrat2 <- as.factor(bundesrat)\n\nbundesrat2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] die Mitte FDP       SVP       FDP       SVP       SP        SP       \nLevels: die Mitte FDP SP SVP\n```\n\n\n:::\n:::\n\nBy default, the factor levels are ordered alphabetically. Sometimes we may want to order the factors, usually for visualisation purposes. To do so, we specify the `levels` in the order we want and set `ordered = TRUE`.\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor(bundesrat, levels = c(\"SP\", \"die Mitte\", \"FDP\", \"SVP\"), ordered = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] die Mitte FDP       SVP       FDP       SVP       SP        SP       \nLevels: SP < die Mitte < FDP < SVP\n```\n\n\n:::\n:::\n\n-->\n\n### Date / time\n\n::: {.cell}\n\n:::\n\nIn most parts of the world, we use the [Gregorian Calendar](https://en.wikipedia.org/wiki/Gregorian_calendar) to communicate a point in time. In this system, we track time as years, months, days, hours, minutes and seconds after a specific event ([*Anno Domini*](https://en.wikipedia.org/wiki/Anno_Domini), \"in the year of the Lord\").\n\nR, just as all other computer systems, do not store date / time information using years, months days etc. Instead, R stores the number of **seconds** after a given date (January 1st, 1970, which is also called *unix epoch*). This information is stored using the class `POSIXct`, which also helps us convert this number of seconds into more human readable information. On 01\\.02\\.2024 at 13:45, 1'706'791'500 have passed since the *unix epoch*, so to store this timestamp, R stores the number 1'706'791'500.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We may have a timestamp saved as a character string\ntoday_txt <- \"2024-02-01 13:45:00\"\n\n# as.POSIXct converts the string to POSIXct:\ntoday_posixct <- as.POSIXct(today_txt)\n\n# When printing a posixct date to the console, it is human readable\ntoday_posixct\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-02-01 13:45:00 CET\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# To see the internally stored value (# of seconds), convert it to numeric:\nas.numeric(today_posixct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1706791500\n```\n\n\n:::\n:::\n\nIf the character string is delivered in the above format (`year-month-day hour:minute:second`), *as.POSIXct* knows how to caluate the number of seconds since *unix epoch*. However, if the format is different, we have to tell R how to read our timestamp. This requires a special syntax, which is described in `?strptime`.\n\n::: {.cell}\n\n```{.r .cell-code}\ndate_txt <- \"01.10.2017 15:15\"\n\n# converts character to POSIXct:\nas.POSIXct(date_txt)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in as.POSIXlt.character(x, tz, ...): character string is not in a standard unambiguous format\n```\n\n\n:::\n\n```{.r .cell-code}\ndate_posix <- as.POSIXct(date_txt, format = \"%d.%m.%Y %H:%M\")\n\ndate_posix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-10-01 15:15:00 CEST\"\n```\n\n\n:::\n:::\n\n\nTheoretically, `strftime` can also be used to extract specific components from a date. However, the functions from `lubridate` are much simpler and we recommend you use these. Note how `strftime` always returns strings while `lubridate` returns more useful datatypes such as integers or factors.\n\n::: {.cell}\n\n```{.r .cell-code}\nstrftime(date_posix, format = \"%m\")           # <1>\nstrftime(date_posix, format = \"%b\")           # <2>\nstrftime(date_posix, format = \"%B\")           # <3>\n```\n:::\n1. extracts the month as a number\n2. extracts the month by name (abbreviated)\n3. extracts the month by name (full)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"lubridate\")\n\nmonth(date_posix)                             # <1>\nmonth(date_posix, label = TRUE, abbr = TRUE)  # <2>\nmonth(date_posix, label = TRUE, abbr = FALSE) # <3>\n```\n:::\n1. extracts the month as a number\n2. extracts the month by name (abbreviated)\n3. extracts the month by name (full)\n\n:::{.callout-important}\n## Time is hard\n\nHandling date / time [is tricky](https://youtu.be/-5wpm-gesOY?si). We recommend the following practices to make life easier:\n\n- Always store time as *POSIXct*, not as text.\n- Always store *time* together with its according date, never separately.\n- If you must extract time (e.g. to analyse daily patterns), store it as [decimal time](https://en.wikipedia.org/wiki/Decimal_time) (e.g. store `15:45` as `15.75`) in a numeric data type.\n- Try to be explicit about which timezone your data originates from\n- If your observation period is affected by switching to or from [daylight saving time](https://en.wikipedia.org/wiki/Daylight_saving_time), think about converting time to *UTC*\n- Use `lubridate` rather than `strftime()`\n:::\n\n\n## Data structures\n\n### Vectors\n\nUsing `c()`, a set of values of the same data type can be assigned to a variable (as a *vector*).\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(10, 20, 33, 42, 54, 66, 77)\nvec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 20 33 42 54 66 77\n```\n\n\n:::\n\n```{.r .cell-code}\n# to extract the 5th element\nvec[5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54\n```\n\n\n:::\n\n```{.r .cell-code}\n# to extract elements 2 to 4\nvec[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20 33 42\n```\n\n\n:::\n:::\n\n### Lists\n\nA `list` is a collection of objects that do not need to be the same data type.\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist <- list(\"q\", TRUE, 3.14)\n```\n:::\n\nThe individual elements in a list can also have assigned names.\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist2 <- list(fav_letter = \"q\", fav_boolean = TRUE, fav_number = 3.14)\n\nmylist2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$fav_letter\n[1] \"q\"\n\n$fav_boolean\n[1] TRUE\n\n$fav_number\n[1] 3.14\n```\n\n\n:::\n:::\n\n### Data frames \n\nIf each entry in a list is the same length, this list can also be represented as a table, which is called a dataframe in R.\n\n::: {.cell}\n\n```{.r .cell-code}\n# note how the names become column names\nas.data.frame(mylist2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  fav_letter fav_boolean fav_number\n1          q        TRUE       3.14\n```\n\n\n:::\n:::\n\nThe `data.frame` function allows a table to be created without first having to create a list.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  City = c(\"Zurich\", \"Geneva\", \"Basel\", \"Bern\", \"Lausanne\"),\n  Arrival = c(\n    \"1.1.2017 10:10\", \"5.1.2017 14:45\",\n    \"8.1.2017 13:15\", \"17.1.2017 18:30\", \"22.1.2017 21:05\"\n  )\n)\n\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t5 obs. of  2 variables:\n $ City   : chr  \"Zurich\" \"Geneva\" \"Basel\" \"Bern\" ...\n $ Arrival: chr  \"1.1.2017 10:10\" \"5.1.2017 14:45\" \"8.1.2017 13:15\" \"17.1.2017 18:30\" ...\n```\n\n\n:::\n:::\n\nThe `$` symbol can be used to query data:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$City\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Zurich\"   \"Geneva\"   \"Basel\"    \"Bern\"     \"Lausanne\"\n```\n\n\n:::\n:::\n\nNew columns can be added and existing ones can be changed:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Residents <- c(400000, 200000, 175000, 14000, 130000)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  City     Arrival         Residents\n  <chr>    <chr>               <dbl>\n1 Zurich   1.1.2017 10:10     400000\n2 Geneva   5.1.2017 14:45     200000\n3 Basel    8.1.2017 13:15     175000\n4 Bern     17.1.2017 18:30     14000\n5 Lausanne 22.1.2017 21:05    130000\n```\n\n\n:::\n:::\n\nWe need to convert the Arrival time to a time format (`POSIXct`).\n\n::: {.cell}\n\n```{.r .cell-code}\n# first, test the output of the \"as.POSIXct\"-function\nas.POSIXct(df$Arrival, format = \"%d.%m.%Y %H:%M\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-01 10:10:00 CET\" \"2017-01-05 14:45:00 CET\"\n[3] \"2017-01-08 13:15:00 CET\" \"2017-01-17 18:30:00 CET\"\n[5] \"2017-01-22 21:05:00 CET\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# if it works, we can save the output to a new column\ndf$Arrival_ct <- as.POSIXct(df$Arrival, format = \"%d.%m.%Y %H:%M\")\n\n\n# We *could* overwrite the old column, but this is a destructive operation!\n```\n:::\n\n\n\nThese columns can now help to create **convenience variables**. E.g., the arrival time can be derived from the `Arrival` column.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Arrival_day <- wday(df$Arrival_ct, label = TRUE, week_start = 1)\n\ndf$Arrival_day\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Sun Thu Sun Tue Sun\nLevels: Mon < Tue < Wed < Thu < Fri < Sat < Sun\n```\n\n\n:::\n:::\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "Prepro1_Demo_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}